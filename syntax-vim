#!/usr/bin/env python3

import sys
from os import makedirs, path as fs
from collections import Iterable

import yaml

from forestanza import __appname__
from forestanza.common import dict_resolve, dict_flatten, getcolumn


class FileLoader:
    CONFIGDIR = fs.dirname(fs.abspath(sys.argv[0]))
    CACHEDIR = fs.join(fs.expanduser('~/.cache'), __appname__)

    def expand_pj(path):
        if isinstance(path, list):
            path = fs.join(*path)
        if not isinstance(path, str):
            return path
        elif path.startswith(":/"):
            return fs.join(FileLoader.CONFIGDIR, path[2:])
        elif path.startswith("@/"):
            if not fs.exists(FileLoader.CACHEDIR):
                makedirs(FileLoader.CACHEDIR)
            return fs.join(FileLoader.CACHEDIR, path[2:])

    def import_yaml(name):
        path = [':', 'cfg', name + '.yml']
        with open(FileLoader.expand_pj(path)) as f:
            return yaml.safe_load(f)

    def export_cache(name, lines):
        path = ['@', name + '.vim']
        with open(FileLoader.expand_pj(path), 'w') as f:
            f.writelines(lines)


class ParseError(Exception):
    """Base class for this program exceptions."""
    pass


def _F_selector(key, idx, main=False):
    def selector_instance(entry):
        ## WARNING can't be dict, as Flatten will expand all items!
        # if isinstance(entry, (dict, OrderedDict)):
        #     return entry.get(key)
        if isinstance(entry, (list, tuple)):
            if not entry or idx >= len(entry):
                return None
            if not isinstance(entry[idx], (str, int)):
                raise ParseError()
            return entry[idx]
        if isinstance(entry, (str, int)):
            return entry if main else None
    return selector_instance


class SynGen:
    CLROPTS = ['ctermfg', 'guifg', 'ctermbg', 'guibg']
    SYNFMT = "syn match fza_{:s} display '\\v\\c{:s}'\n"

    def __init__(self, lang):
        clrs = FileLoader.import_yaml('colorscheme')
        lexs = FileLoader.import_yaml('lexems-' + lang)
        self.clr = {}
        self.dom = list(self.process(clrs, lexs))

    def process(self, clrs, lexs):
        for chain, words in dict_flatten(lexs):
            cchn, cval = dict_resolve(clrs, chain)
            grp = ''.join(cchn)
            if grp not in self.clr:
                self.clr[grp] = cval if isinstance(cval, list) else [cval]
            yield (chain, grp, getcolumn(words, 0), getcolumn(words, 1))

    def make_from(self, idx):
        for entry in self.dom:
            rgx = '|'.join(entry[idx])
            if rgx:
                yield (SynGen.SYNFMT.format(entry[1], rgx))

    def colors(self):
        for grp, clr in sorted(self.clr.items()):
            higlt = "hi def fza_{:s}".format(grp)
            for i, v in enumerate(clr):
                higlt += ' {:s}={:s}'.format(SynGen.CLROPTS[i], str(v))
            yield higlt + "\n"


# NOTE additional fields in word is not supposed to be included into syntax
# highlighting, but can be used for generating popups in some markups.
if __name__ == '__main__':
    syntax = SynGen('jap')
    FileLoader.export_cache('origin', syntax.make_from(2))
    FileLoader.export_cache('phonetic', syntax.make_from(3))
    FileLoader.export_cache('colors', syntax.colors())
