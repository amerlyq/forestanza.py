#!/usr/bin/env python3

import sys
from os import makedirs, path as fs
from collections import OrderedDict, Iterable

import yaml

__appname__ = "forestanza"


class FileLoader:
    CONFIGDIR = fs.dirname(fs.abspath(sys.argv[0]))
    CACHEDIR = fs.join(fs.expanduser('~/.cache'), __appname__)

    def expand_pj(path):
        if not isinstance(path, str):
            return path
        elif path.startswith(":/"):
            return fs.join(FileLoader.CONFIGDIR, path[2:])
        elif path.startswith("@/"):
            if not fs.exists(FileLoader.CACHEDIR):
                makedirs(FileLoader.CACHEDIR)
            return fs.join(FileLoader.CACHEDIR, path[2:])

    # ATTENTION: consider using OrderedDict, if cached .vimrc
    #   is supposed to be included under VCS
    def import_yaml(name):
        path = ':/../cfg/' + name + '.yml'
        with open(FileLoader.expand_pj(path)) as f:
            return yaml.safe_load(f)

    def export_cache(name, lines):
        path = '@/' + name + '.vim'
        with open(FileLoader.expand_pj(path), 'w') as f:
            f.writelines(lines)


class ParseError(Exception):
    """Base class for this program exceptions."""
    pass


def _F_selector(key, idx, main=False):
    def selector_instance(entry):
        ## WARNING can't be dict, as Flatten will expand all items!
        # if isinstance(entry, (dict, OrderedDict)):
        #     return entry.get(key)
        if isinstance(entry, (list, tuple)):
            if not entry or idx >= len(entry):
                return None
            if not isinstance(entry[idx], (str, int)):
                raise ParseError()
            return entry[idx]
        if isinstance(entry, (str, int)):
            return entry if main else None
    return selector_instance

# look up [key] in \w keys of \w group
# - look up [dkey] from the same level
#   - look up [dkey] recursively on above level
# return whole chain
# CANCEL w/o last [dkey] if present

class dictdef(dict):
    def __getitem__(self, key):
        if not isinstance(key, list):
            return self.get(key, self.get(dictdef.KEYDEF))
    # If returns None -- you need to search on upper level

# Maps list chain over dict with default values

KEYDEF = '_'
def resolve_chain(obj, chain, i=0):
    if not isinstance(obj, dict) or i >= len(chain):
        return chain[:i]  # i -- количество удачно пройденных звеньев
    if chain[i] in obj:
        return resolve_chain(obj[chain[i]], chain, i+1)
    if KEYDEF in obj:
        return obj[KEYDEF]

# THINK could be optimized by moving on next step i -> i+1
# and starting from i=1
# return resolve_chain(obj, chain, i+1)


# def dict_intersect(obj, mask):
#     if not isinstance(obj, dict):
#         return obj
#     return {k: dict_intersect(v, mask[k] if '' != k else )
#             for k, v in obj.items()
#             if '' == k or k in mask}


# { k: v['id1'] for k, v in a.items() if 'id1' in v }
class Flatten(list):
    def __init__(self, obj):
        self._flat(obj)

    def _flat(self, obj, chain=[]):
        if not obj:
            return
        if isinstance(obj, (dict, OrderedDict)):
            for k, v in obj.items():
                self._flat(v, chain + [k])
        # elif isinstance(obj, list) and isinstance(obj[0], list):
        # DEV: nested lists for one key-value -- to split lexems logically w/o name.
        else:
            self.append([chain, obj])


class DomFormat:
    def load(name):
        return sorted(Flatten(FileLoader.import_yaml(name)))

    def filter(f, L):
        return [f(x) for x in L if f(x)] if isinstance(L, Iterable) else f(L)

    def select(fsel, dom):
        return [[grp, DomFormat.filter(fsel, ws)] for grp, ws in dom]

    def adapt(lst):
        return [[''.join(grp), '|'.join(ws)] for grp, ws in lst]

    def format(fmt, LL):
        return [fmt.format(*x) for x in LL if '' not in x]


# NOTE all lexems have the same group -- like fza_Pronounce, which repeats
class SynGen:
    def __init__(self, lang):
        self.clr = DomFormat.load('colorscheme')
        self.dom = DomFormat.load('lexems-' + lang)
        print(self.clr)
        # print(self._select(_F_selector('', 0, True), self.clr))
        # print(self._select(_F_selector('origin', 0, True), self.dom))

    def origin(self, fsel=_F_selector('origin', 0, True)):
        return DomFormat.format(
            "syn match fza_{:s} '\\v\\c{:s}'\n",
            DomFormat.adapt(DomFormat.select(fsel, self.dom)))

    def phonetic(self):
        return self.origin(_F_selector('phonetic', 1))

    def colors(self):
        return DomFormat.format(
            "hi def fza_{:s} ctermbg=None guibg=None ctermfg=112 \"{:s}\n",
            DomFormat.adapt(DomFormat.select(lambda x: str(2), self.dom)))


def init():
    yaml.add_constructor(
        'tag:yaml.org,2002:map',
        lambda ldr, node: OrderedDict(ldr.construct_pairs(node)),
        Loader=yaml.SafeLoader)

# NOTE additional fields in word is not supposed to be included into syntax
# highlighting, but can be used for generating popups in some markups.
if __name__ == '__main__':
    init()
    syntax = SynGen('jap')
    for nm in ['origin', 'phonetic', 'colors']:
        FileLoader.export_cache(nm, getattr(syntax, nm)())
